import { MeshStandardMaterial } from 'three';
import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';

class MeshReflectorMaterial extends MeshStandardMaterial {
  constructor(parameters = {}) {
    super(parameters);

    _defineProperty(this, "_tDepth", {
      value: null
    });

    _defineProperty(this, "_tDiffuse", {
      value: null
    });

    _defineProperty(this, "_tDiffuseBlur", {
      value: null
    });

    _defineProperty(this, "_textureMatrix", {
      value: null
    });

    _defineProperty(this, "_hasBlur", {
      value: false
    });

    _defineProperty(this, "_mirror", {
      value: 0.0
    });

    _defineProperty(this, "_mixBlur", {
      value: 0.0
    });

    _defineProperty(this, "_blurStrength", {
      value: 0.5
    });

    _defineProperty(this, "_minDepthThreshold", {
      value: 0.9
    });

    _defineProperty(this, "_maxDepthThreshold", {
      value: 1
    });

    _defineProperty(this, "_depthScale", {
      value: 0
    });

    this.setValues(parameters);
  }

  onBeforeCompile(shader) {
    shader.uniforms.hasBlur = this._hasBlur;
    shader.uniforms.tDiffuse = this._tDiffuse;
    shader.uniforms.tDepth = this._tDepth;
    shader.uniforms.tDiffuseBlur = this._tDiffuseBlur;
    shader.uniforms.textureMatrix = this._textureMatrix;
    shader.uniforms.mirror = this._mirror;
    shader.uniforms.mixBlur = this._mixBlur;
    shader.uniforms.mixStrength = this._blurStrength;
    shader.uniforms.minDepthThreshold = this._minDepthThreshold;
    shader.uniforms.maxDepthThreshold = this._maxDepthThreshold;
    shader.uniforms.depthScale = this._depthScale;
    shader.vertexShader = "\n        uniform mat4 textureMatrix;\n        varying vec4 my_vUv;     \n      " + shader.vertexShader;
    shader.vertexShader = shader.vertexShader.replace('#include <project_vertex>', "#include <project_vertex>\n        my_vUv = textureMatrix * vec4( position, 1.0 );\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );");
    shader.fragmentShader = "\n        uniform sampler2D tDiffuse;\n        uniform sampler2D tDiffuseBlur;\n        uniform sampler2D tDepth;\n        uniform float cameraNear;\n\t\t\t  uniform float cameraFar;\n        uniform bool hasBlur;\n        uniform float mixBlur;\n        uniform float mirror;\n        uniform float mixStrength;\n        uniform float minDepthThreshold;\n        uniform float maxDepthThreshold;\n        uniform float depthScale;\n        varying vec4 my_vUv;        \n        " + shader.fragmentShader;
    shader.fragmentShader = shader.fragmentShader.replace('#include <emissivemap_fragment>', "#include <emissivemap_fragment>\n      \n      vec4 depth = texture2DProj(tDepth, my_vUv );\n      vec4 base = texture2DProj(tDiffuse, my_vUv);\n      vec4 blur = texture2DProj(tDiffuseBlur, my_vUv);\n\n      float depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));\n      depthFactor *= depthScale;\n      depthFactor = min(1.0, depthFactor);\n\n      float reflectorRoughnessFactor = roughness;\n      #ifdef USE_ROUGHNESSMAP\n        vec4 reflectorTexelRoughness = texture2D( roughnessMap, vUv );\n        reflectorRoughnessFactor *= reflectorTexelRoughness.g;\n      #endif\n\n      vec4 merge = base;\n      if (hasBlur) {\n        float blurFactor = min(1.0, mixBlur * reflectorRoughnessFactor);\n        merge = mix(merge, blur, blurFactor);\n      }\n      merge += mix(merge, base, depthFactor);\n      diffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + merge.rgb * mixStrength);           \n      diffuseColor = sRGBToLinear(diffuseColor);");
  }

  get tDiffuse() {
    return this._tDiffuse.value;
  }

  set tDiffuse(v) {
    this._tDiffuse.value = v;
  }

  get tDepth() {
    return this._tDepth.value;
  }

  set tDepth(v) {
    this._tDepth.value = v;
  }

  get tDiffuseBlur() {
    return this._tDiffuseBlur.value;
  }

  set tDiffuseBlur(v) {
    this._tDiffuseBlur.value = v;
  }

  get textureMatrix() {
    return this._textureMatrix.value;
  }

  set textureMatrix(v) {
    this._textureMatrix.value = v;
  }

  get hasBlur() {
    return this._hasBlur.value;
  }

  set hasBlur(v) {
    this._hasBlur.value = v;
  }

  get mirror() {
    return this._mirror.value;
  }

  set mirror(v) {
    this._mirror.value = v;
  }

  get mixBlur() {
    return this._mixBlur.value;
  }

  set mixBlur(v) {
    this._mixBlur.value = v;
  }

  get mixStrength() {
    return this._blurStrength.value;
  }

  set mixStrength(v) {
    this._blurStrength.value = v;
  }

  get minDepthThreshold() {
    return this._minDepthThreshold.value;
  }

  set minDepthThreshold(v) {
    this._minDepthThreshold.value = v;
  }

  get maxDepthThreshold() {
    return this._maxDepthThreshold.value;
  }

  set maxDepthThreshold(v) {
    this._maxDepthThreshold.value = v;
  }

  get depthScale() {
    return this._depthScale.value;
  }

  set depthScale(v) {
    this._depthScale.value = v;
  }

}

export { MeshReflectorMaterial };
