import CloudImage from './assets/cloud.base64.js';
import _extends from '@babel/runtime/helpers/esm/extends';
import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';
import { forwardRef, createElement, useRef, useMemo, useState, useEffect, useLayoutEffect, Children, useImperativeHandle, Fragment, useCallback, useContext, cloneElement } from 'react';
import { useFrame, useLoader, useUpdate, useThree, extend, addEffect, addAfterEffect, applyProps } from 'react-three-fiber';
import mergeRefs from 'react-merge-refs';
import { TextureLoader, Vector2, AudioListener, AudioLoader, PMREMGenerator, CubeTextureLoader, WebGLMultisampleRenderTarget, RGBAFormat, sRGBEncoding, WebGLCubeRenderTarget, LinearFilter, RGBFormat, DefaultLoadingManager, Matrix4, Ray, Sphere as Sphere$1, Vector3, Plane as Plane$1, Vector4, PerspectiveCamera as PerspectiveCamera$1, WebGLRenderTarget, DepthTexture, DepthFormat, UnsignedShortType, Color, Box3, Raycaster, Camera, AnimationMixer, BufferGeometry, MeshPhysicalMaterial, MeshStandardMaterial, ShaderMaterial, UniformsUtils, ShaderChunk, Spherical, AdditiveBlending, PlaneBufferGeometry, Mesh, MeshDepthMaterial, Shape, BufferAttribute, RepeatWrapping } from 'three';
import { LineGeometry } from 'three/examples/jsm/lines/LineGeometry';
import { LineMaterial } from 'three/examples/jsm/lines/LineMaterial';
import { Line2 } from 'three/examples/jsm/lines/Line2';
import { Text as Text$1 } from 'troika-three-text';
import { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader';
import { useAsset } from 'use-asset';
import { presetsObj } from './helpers/environment-assets.js';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass';
import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass';
import { GammaCorrectionShader } from 'three/examples/jsm/shaders/GammaCorrectionShader';
import { SimplexNoise } from 'three/examples/jsm/math/SimplexNoise';
import { DeviceOrientationControls as DeviceOrientationControls$1 } from 'three/examples/jsm/controls/DeviceOrientationControls';
import { FlyControls as FlyControls$1 } from 'three/examples/jsm/controls/FlyControls';
import { MapControls as MapControls$1, OrbitControls as OrbitControls$1 } from 'three/examples/jsm/controls/OrbitControls';
import { TrackballControls as TrackballControls$1 } from 'three/examples/jsm/controls/TrackballControls';
import { TransformControls as TransformControls$1 } from 'three/examples/jsm/controls/TransformControls';
import pick from 'lodash.pick';
import omit from 'lodash.omit';
import { PointerLockControls as PointerLockControls$1 } from 'three/examples/jsm/controls/PointerLockControls';
import { FBXLoader } from 'three/examples/jsm/loaders/FBXLoader';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';
import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader';
import { MeshoptDecoder } from 'three/examples/jsm/libs/meshopt_decoder.module.js';
import create$1 from 'zustand';
import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';
import { M as MeshReflectorMaterial, B as BlurPass } from './MeshReflectorMaterial-fdc52c9a.js';
import StatsImpl from 'three/examples/js/libs/stats.min';
import { getGPUTier } from 'detect-gpu';
import { SimplifyModifier } from 'three/examples/jsm/modifiers/SimplifyModifier';
import { TessellateModifier } from 'three/examples/jsm/modifiers/TessellateModifier';
import { EdgeSplitModifier } from 'three/examples/jsm/modifiers/EdgeSplitModifier';
import { Flow } from 'three/examples/jsm/modifiers/CurveModifier';
import { Sky as Sky$1 } from 'three/examples/jsm/objects/Sky';
import { HorizontalBlurShader } from 'three/examples/jsm/shaders/HorizontalBlurShader';
import { VerticalBlurShader } from 'three/examples/jsm/shaders/VerticalBlurShader';
import { matcapList } from './helpers/matcap-assets.js';
import { normalsList } from './helpers/normal-assets.js';

function create(type) {
  const El = type + 'BufferGeometry';
  return /*#__PURE__*/forwardRef((_ref, ref) => {
    let {
      args,
      children
    } = _ref,
        props = _objectWithoutPropertiesLoose(_ref, ["args", "children"]);

    return /*#__PURE__*/createElement("mesh", _extends({
      ref: ref
    }, props), /*#__PURE__*/createElement(El, {
      attach: "geometry",
      args: args
    }), children);
  });
}

const Box = create('box');
const Circle = create('circle');
const Cone = create('cone');
const Cylinder = create('cylinder');
const Sphere = create('sphere');
const Plane = create('plane');
const Tube = create('tube');
const Torus = create('torus');
const TorusKnot = create('torusKnot');
const Tetrahedron = create('tetrahedron');
const Ring = create('ring');
const Polyhedron = create('polyhedron');
const Icosahedron = create('icosahedron');
const Octahedron = create('octahedron');
const Dodecahedron = create('dodecahedron');
const Extrude = create('extrude');
const Lathe = create('lathe');
const Parametric = create('parametric');

const Billboard = /*#__PURE__*/forwardRef(function Billboard(_ref, ref) {
  let {
    follow = true,
    lockX = false,
    lockY = false,
    lockZ = false
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["follow", "lockX", "lockY", "lockZ"]);

  const localRef = useRef();
  useFrame(({
    camera
  }) => {
    if (!follow) return;

    if (localRef.current) {
      const prev = {
        x: localRef.current.rotation.x,
        y: localRef.current.rotation.y,
        z: localRef.current.rotation.z
      };
      localRef.current.lookAt(camera.position); // readjust any axis that is locked

      if (lockX) localRef.current.rotation.x = prev.x;
      if (lockY) localRef.current.rotation.y = prev.y;
      if (lockZ) localRef.current.rotation.z = prev.z;
    }
  });
  return /*#__PURE__*/createElement(Plane, _extends({
    ref: mergeRefs([localRef, ref])
  }, props));
});

function useTexture(url) {
  return useLoader(TextureLoader, url);
}

useTexture.preload = url => useLoader.preload(TextureLoader, url);

function Cloud(_ref) {
  let {
    opacity = 0.5,
    speed = 0.4,
    width = 10,
    length = 1.5,
    segments = 20,
    dir = 1
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["opacity", "speed", "width", "length", "segments", "dir"]);

  const group = useRef();
  const texture = useTexture(CloudImage);
  const clouds = useMemo(() => [...new Array(segments)].map((_, index) => ({
    x: width / 2 - Math.random() * width,
    y: width / 2 - Math.random() * width,
    scale: 0.4 + Math.sin((index + 1) / segments * Math.PI) * ((0.2 + Math.random()) * 10),
    density: Math.max(0.2, Math.random()),
    rotation: Math.max(0.002, 0.005 * Math.random()) * speed
  })), [width, segments, speed]);
  useFrame(state => {
    var _group$current;

    return (_group$current = group.current) == null ? void 0 : _group$current.children.forEach((cloud, index) => {
      cloud.rotation.z += clouds[index].rotation * dir;
      cloud.scale.setScalar(clouds[index].scale + (1 + Math.sin(state.clock.getElapsedTime() / 10)) / 2 * index / 10);
    });
  });
  return /*#__PURE__*/createElement("group", props, /*#__PURE__*/createElement("group", {
    position: [0, 0, segments / 2 * length],
    ref: group
  }, clouds.map(({
    x,
    y,
    scale,
    density
  }, index) => /*#__PURE__*/createElement(Billboard, {
    key: index,
    scale: [scale, scale, scale],
    position: [x, y, -index * length],
    lockZ: true
  }, /*#__PURE__*/createElement("meshStandardMaterial", {
    map: texture,
    transparent: true,
    opacity: scale / 6 * density * opacity,
    depthTest: false
  })))));
}

const Detailed = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    children,
    distances
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["children", "distances"]);

  const lod = useUpdate(lod => {
    lod.levels.length = 0;
    lod.children.forEach((object, index) => lod.levels.push({
      object,
      distance: distances[index]
    }));
  }, []);
  useFrame(state => {
    var _lod$current;

    return (_lod$current = lod.current) == null ? void 0 : _lod$current.update(state.camera);
  });
  return /*#__PURE__*/createElement("lOD", _extends({
    ref: mergeRefs([lod, ref])
  }, props), children);
});

const Line = /*#__PURE__*/forwardRef(function Line(_ref, ref) {
  let {
    points,
    color = 'black',
    vertexColors,
    lineWidth,
    dashed
  } = _ref,
      rest = _objectWithoutPropertiesLoose(_ref, ["points", "color", "vertexColors", "lineWidth", "dashed"]);

  const [line2] = useState(() => new Line2());
  const [lineMaterial] = useState(() => new LineMaterial());
  const [resolution] = useState(() => new Vector2(512, 512));
  const lineGeom = useMemo(() => {
    const geom = new LineGeometry();
    geom.setPositions(points.flat());

    if (vertexColors) {
      geom.setColors(vertexColors.flat());
    }

    return geom;
  }, [points, vertexColors]);
  useEffect(() => {
    line2.computeLineDistances();
  }, [line2]);
  useLayoutEffect(() => {
    if (dashed) {
      lineMaterial.defines.USE_DASH = '';
    } else {
      // Setting lineMaterial.defines.USE_DASH to undefined is apparently not sufficient.
      delete lineMaterial.defines.USE_DASH;
    }

    lineMaterial.needsUpdate = true;
  }, [dashed, lineMaterial]);
  return /*#__PURE__*/createElement("primitive", _extends({
    dispose: undefined,
    object: line2,
    ref: ref
  }, rest), /*#__PURE__*/createElement("primitive", {
    dispose: undefined,
    object: lineGeom,
    attach: "geometry"
  }), /*#__PURE__*/createElement("primitive", _extends({
    dispose: undefined,
    object: lineMaterial,
    attach: "material",
    color: color,
    vertexColors: Boolean(vertexColors),
    resolution: resolution,
    linewidth: lineWidth,
    dashed: dashed
  }, rest)));
});

const PositionalAudio = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    url,
    distance = 1,
    loop = true
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["url", "distance", "loop"]);

  const sound = useRef();
  const {
    camera
  } = useThree();
  const [listener] = useState(() => new AudioListener());
  const buffer = useLoader(AudioLoader, url);
  useEffect(() => {
    const _sound = sound.current;

    if (_sound) {
      _sound.setBuffer(buffer);

      _sound.setRefDistance(distance);

      _sound.setLoop(loop);

      _sound.play();
    }

    camera.add(listener);
    return () => {
      camera.remove(listener);

      if (_sound) {
        _sound.stop();

        _sound.disconnect();
      }
    };
  }, [buffer, camera, distance, listener, loop]);
  return /*#__PURE__*/createElement("positionalAudio", _extends({
    ref: mergeRefs([sound, ref]),
    args: [listener]
  }, props));
});

// eslint-disable-next-line prettier/prettier
const Text = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    anchorX = 'center',
    anchorY = 'middle',
    children,
    onSync
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["anchorX", "anchorY", "children", "onSync"]);

  const {
    invalidate
  } = useThree();
  const [troikaMesh] = useState(() => new Text$1());
  const [nodes, text] = useMemo(() => {
    let n = [];
    let t = '';
    Children.forEach(children, child => {
      if (typeof child === 'string' || typeof child === 'number') {
        t += child;
      } else {
        n.push(child);
      }
    });
    return [n, t];
  }, [children]);
  useLayoutEffect(() => void troikaMesh.sync(() => {
    invalidate();
    if (onSync) onSync(troikaMesh);
  }));
  return /*#__PURE__*/createElement("primitive", _extends({
    dispose: undefined,
    object: troikaMesh,
    ref: ref,
    text: text,
    anchorX: anchorX,
    anchorY: anchorY
  }, props), nodes);
});

function getTexture(texture, gen, isCubeMap) {
  if (isCubeMap) {
    gen.compileEquirectangularShader();
    return gen.fromCubemap(texture).texture;
  }

  return gen.fromEquirectangular(texture).texture;
}

const CUBEMAP_ROOT = 'https://rawcdn.githack.com/mattrossman/drei-assets/b597559ff62f85ec691df28cbea5ecb1263a2085';
function Environment({
  background = false,
  files = ['px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png'],
  path = '/',
  preset = undefined,
  scene
}) {
  if (preset) {
    if (!(preset in presetsObj)) {
      throw new Error('Preset must be one of: ' + Object.keys(presetsObj).join(', '));
    }

    files = presetsObj[preset];
    path = CUBEMAP_ROOT + '/hdri/';
  }

  const {
    gl,
    scene: defaultScene
  } = useThree();
  const isCubeMap = Array.isArray(files);
  const loader = isCubeMap ? CubeTextureLoader : RGBELoader; // @ts-expect-error

  const loaderResult = useLoader(loader, isCubeMap ? [files] : files, loader => loader.setPath(path));
  const map = isCubeMap ? loaderResult[0] : loaderResult; // PMREMGenerator takes its sweet time to generate the env-map,
  // Let's make this part of suspense, or else it just yields a frame-skip

  const texture = useAsset(() => new Promise(res => {
    const gen = new PMREMGenerator(gl);
    const texture = getTexture(map, gen, isCubeMap);
    gen.dispose();
    map.dispose();
    res(texture);
  }), map);
  useLayoutEffect(() => {
    const oldbg = scene ? scene.background : defaultScene.background;
    const oldenv = scene ? scene.environment : defaultScene.environment;

    if (scene) {
      scene.environment = texture;

      if (background) {
        scene.background = texture;
      }
    } else {
      defaultScene.environment = texture;

      if (background) {
        defaultScene.background = texture;
      }
    }

    return () => {
      if (scene) {
        scene.environment = oldenv;
        scene.background = oldbg;
      } else {
        defaultScene.environment = oldenv;
        defaultScene.background = oldbg;
      }
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [texture, background, scene]);
  return null;
}

extend({
  EffectComposer,
  RenderPass,
  ShaderPass
});
const isWebGL2Available = () => {
  try {
    var canvas = document.createElement('canvas');
    return !!(window.WebGL2RenderingContext && canvas.getContext('webgl2'));
  } catch (e) {
    return false;
  }
};
const Effects = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    children,
    multisamping = 8,
    renderIndex = 1,
    disableGamma = false,
    disableRenderPass = false
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["children", "multisamping", "renderIndex", "disableGamma", "disableRenderPass"]);

  const composer = useRef();
  const {
    scene,
    camera,
    gl,
    size
  } = useThree();
  const [target] = useState(() => {
    if (isWebGL2Available() && multisamping > 0) {
      const t = new WebGLMultisampleRenderTarget(size.width, size.height, {
        format: RGBAFormat,
        encoding: sRGBEncoding
      });
      t.samples = 8;
      return t;
    }
  });
  useEffect(() => {
    var _composer$current, _composer$current2;

    (_composer$current = composer.current) == null ? void 0 : _composer$current.setSize(size.width, size.height);
    (_composer$current2 = composer.current) == null ? void 0 : _composer$current2.setPixelRatio(gl.getPixelRatio());
  }, [gl, size]);
  useFrame(() => {
    var _composer$current3;

    return (_composer$current3 = composer.current) == null ? void 0 : _composer$current3.render();
  }, renderIndex);
  return /*#__PURE__*/createElement("effectComposer", _extends({
    ref: mergeRefs([ref, composer]),
    args: [gl, target]
  }, props), !disableRenderPass && /*#__PURE__*/createElement("renderPass", {
    attachArray: "passes",
    args: [scene, camera]
  }), !disableGamma && /*#__PURE__*/createElement("shaderPass", {
    attachArray: "passes",
    args: [GammaCorrectionShader]
  }), children);
});

const OrthographicCamera = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    makeDefault = false
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["makeDefault"]);

  const {
    setDefaultCamera,
    camera,
    size
  } = useThree();
  const cameraRef = useUpdate(cam => cam.updateProjectionMatrix(), [size, props]);
  useLayoutEffect(() => {
    if (makeDefault && cameraRef.current) {
      const oldCam = camera;
      setDefaultCamera(cameraRef.current);
      return () => setDefaultCamera(oldCam);
    }
  }, [camera, cameraRef, makeDefault, setDefaultCamera]);
  return /*#__PURE__*/createElement("orthographicCamera", _extends({
    left: size.width / -2,
    right: size.width / 2,
    top: size.height / 2,
    bottom: size.height / -2,
    ref: mergeRefs([cameraRef, ref])
  }, props));
});

const PerspectiveCamera = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    makeDefault = false
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["makeDefault"]);

  const {
    setDefaultCamera,
    camera,
    size
  } = useThree();
  const cameraRef = useUpdate(cam => {
    cam.aspect = size.width / size.height;
    cam.updateProjectionMatrix();
  }, [size, props]);
  useLayoutEffect(() => {
    if (makeDefault && cameraRef.current) {
      const oldCam = camera;
      setDefaultCamera(cameraRef.current);
      return () => setDefaultCamera(oldCam);
    }
  }, [camera, cameraRef, makeDefault, setDefaultCamera]);
  return /*#__PURE__*/createElement("perspectiveCamera", _extends({
    ref: mergeRefs([cameraRef, ref])
  }, props));
});

const CameraShake = /*#__PURE__*/forwardRef(({
  intensity = 1,
  decay,
  decayRate = 0.65,
  maxYaw = 0.1,
  maxPitch = 0.1,
  maxRoll = 0.1,
  yawFrequency = 1,
  pitchFrequency = 1,
  rollFrequency = 1,
  additive
}, ref) => {
  const {
    camera
  } = useThree();
  const intensityRef = useRef(intensity);
  const [yawNoise] = useState(() => new SimplexNoise());
  const [pitchNoise] = useState(() => new SimplexNoise());
  const [rollNoise] = useState(() => new SimplexNoise());

  const constrainIntensity = () => {
    if (intensityRef.current < 0 || intensityRef.current > 1) {
      intensityRef.current = intensityRef.current < 0 ? 0 : 1;
    }
  };

  useImperativeHandle(ref, () => ({
    getIntensity: () => intensityRef.current,
    setIntensity: val => {
      intensityRef.current = val;
      constrainIntensity();
    }
  }), []);
  useFrame(({
    clock
  }, delta) => {
    const shake = Math.pow(intensityRef.current, 2);
    const yaw = maxYaw * shake * yawNoise.noise(clock.elapsedTime * yawFrequency, 1);
    const pitch = maxPitch * shake * pitchNoise.noise(clock.elapsedTime * pitchFrequency, 1);
    const roll = maxRoll * shake * rollNoise.noise(clock.elapsedTime * rollFrequency, 1);

    if (additive) {
      camera.rotation.x += pitch;
      camera.rotation.y += yaw;
      camera.rotation.z += roll;
    } else {
      camera.rotation.set(pitch, yaw, roll);
    }

    if (decay && intensityRef.current > 0) {
      intensityRef.current -= decayRate * delta;
      constrainIntensity();
    }
  });
  return null;
});

function CubeCamera(_ref) {
  let {
    children,
    fog,
    frames = Infinity,
    resolution = 256,
    near = 1,
    far = 1000
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["children", "fog", "frames", "resolution", "near", "far"]);

  const ref = useRef();
  const [camera, setCamera] = useState();
  const {
    scene,
    gl
  } = useThree();
  const fbo = useMemo(() => new WebGLCubeRenderTarget(resolution, {
    minFilter: LinearFilter,
    magFilter: LinearFilter,
    format: RGBFormat,
    encoding: gl.outputEncoding
  }), [resolution]);
  let count = 0;
  useFrame(() => {
    if (camera && ref.current && (frames === Infinity || count < frames)) {
      ref.current.traverse(obj => obj.visible = false);
      const originalFog = scene.fog;
      scene.fog = fog != null ? fog : originalFog;
      camera.update(gl, scene);
      scene.fog = originalFog;
      ref.current.traverse(obj => obj.visible = true);
      count++;
    }
  });
  return /*#__PURE__*/createElement("group", props, /*#__PURE__*/createElement("cubeCamera", {
    ref: setCamera,
    args: [near, far, fbo]
  }), /*#__PURE__*/createElement("group", {
    ref: ref
  }, children(fbo.texture)));
}

function call(ref, value) {
  if (typeof ref === 'function') ref(value);else if (ref != null) ref.current = value;
}

function useEffectfulState(fn, deps = [], cb) {
  const [state, set] = useState();
  useLayoutEffect(() => {
    const value = fn();
    set(value);
    call(cb, value);
    return () => call(cb, null); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, deps);
  return state;
}

const DeviceOrientationControls = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    camera,
    invalidate
  } = useThree();
  const controls = useEffectfulState(() => new DeviceOrientationControls$1(camera), [camera], ref);
  useEffect(() => {
    controls == null ? void 0 : controls.addEventListener == null ? void 0 : controls.addEventListener('change', invalidate);
    return () => controls == null ? void 0 : controls.removeEventListener == null ? void 0 : controls.removeEventListener('change', invalidate);
  }, [controls, invalidate]);
  useFrame(() => controls == null ? void 0 : controls.update());
  useEffect(() => {
    const current = controls;
    current == null ? void 0 : current.connect();
    return () => current == null ? void 0 : current.dispose();
  }, [controls]);
  return controls ? /*#__PURE__*/createElement("primitive", _extends({
    dispose: undefined,
    object: controls
  }, props)) : null;
});

const FlyControls = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    camera,
    gl,
    invalidate
  } = useThree();
  const controls = useEffectfulState(() => new FlyControls$1(camera, gl.domElement), [camera, gl.domElement], ref);
  useEffect(() => {
    controls == null ? void 0 : controls.addEventListener == null ? void 0 : controls.addEventListener('change', invalidate);
    return () => controls == null ? void 0 : controls.removeEventListener == null ? void 0 : controls.removeEventListener('change', invalidate);
  }, [controls, invalidate]);
  useFrame((_, delta) => controls == null ? void 0 : controls.update(delta));
  return controls ? /*#__PURE__*/createElement("primitive", _extends({
    dispose: undefined,
    object: controls
  }, props)) : null;
});

const MapControls = /*#__PURE__*/forwardRef((props = {
  enableDamping: true
}, ref) => {
  const {
    camera,
    gl,
    invalidate
  } = useThree();
  const controls = useEffectfulState(() => new MapControls$1(camera, gl.domElement), [camera, gl], ref);
  useFrame(() => controls == null ? void 0 : controls.update());
  useEffect(() => {
    controls == null ? void 0 : controls.addEventListener == null ? void 0 : controls.addEventListener('change', invalidate);
    return () => controls == null ? void 0 : controls.removeEventListener == null ? void 0 : controls.removeEventListener('change', invalidate);
  }, [controls, invalidate]);
  return controls ? /*#__PURE__*/createElement("primitive", _extends({
    dispose: undefined,
    object: controls,
    enableDamping: true
  }, props)) : null;
});

const OrbitControls = /*#__PURE__*/forwardRef((props = {
  enableDamping: true
}, ref) => {
  const {
    camera,
    gl,
    invalidate
  } = useThree();
  const controls = useEffectfulState(() => new OrbitControls$1(camera, gl.domElement), [camera, gl], ref);
  useFrame(() => controls == null ? void 0 : controls.update());
  useEffect(() => {
    controls == null ? void 0 : controls.addEventListener == null ? void 0 : controls.addEventListener('change', invalidate);
    return () => controls == null ? void 0 : controls.removeEventListener == null ? void 0 : controls.removeEventListener('change', invalidate);
  }, [controls, invalidate]);
  return controls ? /*#__PURE__*/createElement("primitive", _extends({
    dispose: undefined,
    object: controls,
    enableDamping: true
  }, props)) : null;
});

const TrackballControls = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    camera,
    gl,
    invalidate
  } = useThree();
  const controls = useEffectfulState(() => new TrackballControls$1(camera, gl.domElement), [camera, gl], ref);
  useFrame(() => controls == null ? void 0 : controls.update());
  useEffect(() => {
    controls == null ? void 0 : controls.addEventListener == null ? void 0 : controls.addEventListener('change', invalidate);
    return () => controls == null ? void 0 : controls.removeEventListener == null ? void 0 : controls.removeEventListener('change', invalidate);
  }, [controls, invalidate]);
  return controls ? /*#__PURE__*/createElement("primitive", _extends({
    dispose: undefined,
    object: controls
  }, props)) : null;
});

const TransformControls = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    children
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["children"]);

  const transformOnlyPropNames = ['enabled', 'axis', 'mode', 'translationSnap', 'rotationSnap', 'scaleSnap', 'space', 'size', 'dragging', 'showX', 'showY', 'showZ'];
  const transformProps = pick(props, transformOnlyPropNames);
  const objectProps = omit(props, transformOnlyPropNames);
  const {
    camera,
    gl,
    invalidate
  } = useThree();
  const controls = useEffectfulState(() => new TransformControls$1(camera, gl.domElement), [camera, gl.domElement], ref);
  const group = useRef();
  useLayoutEffect(() => void (controls == null ? void 0 : controls.attach(group.current)), [children, controls]);
  useEffect(() => {
    controls == null ? void 0 : controls.addEventListener == null ? void 0 : controls.addEventListener('change', invalidate);
    return () => controls == null ? void 0 : controls.removeEventListener == null ? void 0 : controls.removeEventListener('change', invalidate);
  }, [controls, invalidate]);
  return controls ? /*#__PURE__*/createElement(Fragment, null, /*#__PURE__*/createElement("primitive", _extends({
    dispose: undefined,
    object: controls
  }, transformProps)), /*#__PURE__*/createElement("group", _extends({
    ref: group
  }, objectProps), children)) : null;
});

const PointerLockControls = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    selector
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["selector"]);

  const {
    camera,
    gl,
    invalidate
  } = useThree();
  const controls = useEffectfulState(() => new PointerLockControls$1(camera, gl.domElement), [camera, gl.domElement], ref);
  useEffect(() => {
    controls == null ? void 0 : controls.addEventListener == null ? void 0 : controls.addEventListener('change', invalidate);
    return () => controls == null ? void 0 : controls.removeEventListener == null ? void 0 : controls.removeEventListener('change', invalidate);
  }, [controls, invalidate]);
  useEffect(() => {
    const handler = () => controls == null ? void 0 : controls.lock();

    const element = selector ? document.querySelector(selector) : document;
    element && element.addEventListener('click', handler);
    return () => element ? element.removeEventListener('click', handler) : undefined;
  }, [controls, selector]);
  return controls ? /*#__PURE__*/createElement("primitive", _extends({
    dispose: undefined,
    object: controls
  }, props)) : null;
});

function useCubeTexture(files, {
  path
}) {
  // @ts-ignore
  const [cubeTexture] = useLoader( // @ts-ignore
  CubeTextureLoader, [files], loader => loader.setPath(path));
  return cubeTexture;
}

useCubeTexture.preload = (files, {
  path
}) => useLoader.preload( // @ts-ignore
CubeTextureLoader, [files], loader => loader.setPath(path));

function useFBX(path) {
  return useLoader(FBXLoader, path);
}

useFBX.preload = path => useLoader.preload(FBXLoader, path);

function extensions(useDraco, useMeshopt) {
  return loader => {
    if (useDraco) {
      const dracoLoader = new DRACOLoader();
      dracoLoader.setDecoderPath(typeof useDraco === 'string' ? useDraco : 'https://www.gstatic.com/draco/v1/decoders/');
      loader.setDRACOLoader(dracoLoader);
    }

    if (useMeshopt) {
      loader.setMeshoptDecoder(MeshoptDecoder);
    }
  };
}

function useGLTF(path, useDraco = true, useMeshOpt = true) {
  const gltf = useLoader(GLTFLoader, path, extensions(useDraco, useMeshOpt));
  return gltf;
}

useGLTF.preload = (path, useDraco = true, useMeshOpt = true) => useLoader.preload(GLTFLoader, path, extensions(useDraco, useMeshOpt));

let saveLastTotalLoaded = 0;
const useProgress = create$1(set => {
  DefaultLoadingManager.onStart = (item, loaded, total) => {
    set({
      active: true,
      item,
      loaded,
      total,
      progress: (loaded - saveLastTotalLoaded) / (total - saveLastTotalLoaded) * 100
    });
  };

  DefaultLoadingManager.onLoad = () => set({
    active: false
  });

  DefaultLoadingManager.onError = item => set(state => ({
    errors: [...state.errors, item]
  }));

  DefaultLoadingManager.onProgress = (item, loaded, total) => {
    if (loaded === total) {
      saveLastTotalLoaded = total;
    }

    set({
      item,
      loaded,
      total,
      progress: (loaded - saveLastTotalLoaded) / (total - saveLastTotalLoaded) * 100 || 100
    });
  };

  return {
    errors: [],
    active: false,
    progress: 0,
    item: '',
    loaded: 0,
    total: 0
  };
});

let _inverseMatrix = new Matrix4();

let _ray = new Ray();

let _sphere = new Sphere$1();

let _vA = new Vector3();

function meshBounds(raycaster, intersects) {
  let geometry = this.geometry;
  let material = this.material;
  let matrixWorld = this.matrixWorld;
  if (material === undefined) return; // Checking boundingSphere distance to ray

  if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

  _sphere.copy(geometry.boundingSphere);

  _sphere.applyMatrix4(matrixWorld);

  if (raycaster.ray.intersectsSphere(_sphere) === false) return;

  _inverseMatrix.copy(matrixWorld).invert();

  _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix); // Check boundingBox before continuing


  if (geometry.boundingBox !== null && _ray.intersectBox(geometry.boundingBox, _vA) === null) return;
  intersects.push({
    distance: _vA.distanceTo(raycaster.ray.origin),
    point: _vA.clone(),
    object: this
  });
}

extend({
  MeshReflectorMaterial
});
const Reflector = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    mixBlur = 0.0,
    mixStrength = 0.5,
    resolution = 256,
    blur = [0, 0],
    args = [1, 1],
    minDepthThreshold = 0.9,
    maxDepthThreshold = 1,
    depthScale = 0,
    depthToBlurRatioBias = 0.25,
    mirror,
    children,
    debug = 0,
    distortion = 1,
    distortionMap
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["mixBlur", "mixStrength", "resolution", "blur", "args", "minDepthThreshold", "maxDepthThreshold", "depthScale", "depthToBlurRatioBias", "mirror", "children", "debug", "distortion", "distortionMap"]);

  blur = Array.isArray(blur) ? blur : [blur, blur];
  const hasBlur = blur[0] + blur[1] > 0;
  const meshRef = useRef(null);
  const [reflectorPlane] = useState(() => new Plane$1());
  const [normal] = useState(() => new Vector3());
  const [reflectorWorldPosition] = useState(() => new Vector3());
  const [cameraWorldPosition] = useState(() => new Vector3());
  const [rotationMatrix] = useState(() => new Matrix4());
  const [lookAtPosition] = useState(() => new Vector3(0, 0, -1));
  const [clipPlane] = useState(() => new Vector4());
  const [view] = useState(() => new Vector3());
  const [target] = useState(() => new Vector3());
  const [q] = useState(() => new Vector4());
  const [textureMatrix] = useState(() => new Matrix4());
  const [virtualCamera] = useState(() => new PerspectiveCamera$1());
  const {
    gl,
    scene,
    camera
  } = useThree();
  const beforeRender = useCallback(() => {
    reflectorWorldPosition.setFromMatrixPosition(meshRef.current.matrixWorld);
    cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
    rotationMatrix.extractRotation(meshRef.current.matrixWorld);
    normal.set(0, 0, 1);
    normal.applyMatrix4(rotationMatrix);
    view.subVectors(reflectorWorldPosition, cameraWorldPosition); // Avoid rendering when reflector is facing away

    if (view.dot(normal) > 0) return;
    view.reflect(normal).negate();
    view.add(reflectorWorldPosition);
    rotationMatrix.extractRotation(camera.matrixWorld);
    lookAtPosition.set(0, 0, -1);
    lookAtPosition.applyMatrix4(rotationMatrix);
    lookAtPosition.add(cameraWorldPosition);
    target.subVectors(reflectorWorldPosition, lookAtPosition);
    target.reflect(normal).negate();
    target.add(reflectorWorldPosition);
    virtualCamera.position.copy(view);
    virtualCamera.up.set(0, 1, 0);
    virtualCamera.up.applyMatrix4(rotationMatrix);
    virtualCamera.up.reflect(normal);
    virtualCamera.lookAt(target);
    virtualCamera.far = camera.far; // Used in WebGLBackground

    virtualCamera.updateMatrixWorld();
    virtualCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix

    textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
    textureMatrix.multiply(virtualCamera.projectionMatrix);
    textureMatrix.multiply(virtualCamera.matrixWorldInverse);
    textureMatrix.multiply(meshRef.current.matrixWorld); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html
    // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf

    reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);
    reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);
    clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);
    const projectionMatrix = virtualCamera.projectionMatrix;
    q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
    q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
    q.z = -1.0;
    q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector

    clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix

    projectionMatrix.elements[2] = clipPlane.x;
    projectionMatrix.elements[6] = clipPlane.y;
    projectionMatrix.elements[10] = clipPlane.z + 1.0;
    projectionMatrix.elements[14] = clipPlane.w; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  const [fbo1, fbo2, blurpass, reflectorProps] = useMemo(() => {
    const parameters = {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      format: RGBFormat,
      encoding: gl.outputEncoding
    };
    const fbo1 = new WebGLRenderTarget(resolution, resolution, parameters);
    fbo1.depthBuffer = true;
    fbo1.depthTexture = new DepthTexture(resolution, resolution);
    fbo1.depthTexture.format = DepthFormat;
    fbo1.depthTexture.type = UnsignedShortType;
    const fbo2 = new WebGLRenderTarget(resolution, resolution, parameters);
    const blurpass = new BlurPass({
      gl,
      resolution,
      width: blur[0],
      height: blur[1],
      minDepthThreshold,
      maxDepthThreshold,
      depthScale,
      depthToBlurRatioBias
    });
    const reflectorProps = {
      mirror,
      textureMatrix,
      mixBlur,
      tDiffuse: fbo1.texture,
      tDepth: fbo1.depthTexture,
      tDiffuseBlur: fbo2.texture,
      hasBlur,
      mixStrength,
      minDepthThreshold,
      maxDepthThreshold,
      depthScale,
      depthToBlurRatioBias,
      transparent: true,
      debug,
      distortion,
      distortionMap,
      'defines-USE_BLUR': hasBlur ? '' : undefined,
      'defines-USE_DEPTH': depthScale > 0 ? '' : undefined,
      'defines-USE_DISTORTION': !!distortionMap ? '' : undefined
    };
    return [fbo1, fbo2, blurpass, reflectorProps];
  }, [gl, blur, textureMatrix, resolution, mirror, hasBlur, mixBlur, mixStrength, minDepthThreshold, maxDepthThreshold, depthScale, depthToBlurRatioBias, debug, distortion, distortionMap]);
  useFrame(() => {
    if (!(meshRef == null ? void 0 : meshRef.current)) return;
    meshRef.current.visible = false;
    beforeRender();
    gl.setRenderTarget(fbo1);
    gl.render(scene, virtualCamera);
    if (hasBlur) blurpass.render(gl, fbo1, fbo2);
    meshRef.current.visible = true;
    gl.setRenderTarget(null);
  });
  return /*#__PURE__*/createElement("mesh", _extends({
    ref: mergeRefs([meshRef, ref])
  }, props), /*#__PURE__*/createElement("planeBufferGeometry", {
    args: args
  }), children ? children('meshReflectorMaterial', reflectorProps) : /*#__PURE__*/createElement("meshReflectorMaterial", reflectorProps));
});

const Shadow = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    fog = false,
    colorStop = 0.0,
    color = 'black',
    opacity = 0.5
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["fog", "colorStop", "color", "opacity"]);

  const canvas = useMemo(() => {
    let canvas = document.createElement('canvas');
    canvas.width = 128;
    canvas.height = 128;
    let context = canvas.getContext('2d');
    let gradient = context.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
    gradient.addColorStop(colorStop, new Color(color).getStyle());
    gradient.addColorStop(1, 'rgba(0,0,0,0)');
    context.fillStyle = gradient;
    context.fillRect(0, 0, canvas.width, canvas.height);
    return canvas;
  }, [color, colorStop]);
  return /*#__PURE__*/createElement("mesh", _extends({
    ref: ref
  }, props), /*#__PURE__*/createElement("planeBufferGeometry", {
    attach: "geometry",
    args: [1, 1]
  }), /*#__PURE__*/createElement("meshBasicMaterial", {
    attach: "material",
    transparent: true,
    opacity: opacity,
    fog: fog
  }, /*#__PURE__*/createElement("canvasTexture", {
    attach: "map",
    args: [canvas]
  })));
});

function Stats({
  showPanel = 0,
  className,
  parent
}) {
  const stats = useEffectfulState(() => new StatsImpl(), []);
  useEffect(() => {
    if (stats) {
      const node = parent && parent.current || document.body;
      stats.showPanel(showPanel);
      node == null ? void 0 : node.appendChild(stats.dom);
      if (className) stats.dom.classList.add(className);
      const begin = addEffect(() => stats.begin());
      const end = addAfterEffect(() => stats.end());
      return () => {
        node == null ? void 0 : node.removeChild(stats.dom);
        begin();
        end();
      };
    }
  }, [parent, stats, className, showPanel]);
  return null;
}

const Center = /*#__PURE__*/forwardRef(function Center(_ref, ref) {
  let {
    children
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["children"]);

  const outer = useRef();
  const inner = useRef();
  useLayoutEffect(() => {
    if (inner.current && outer.current) {
      const box = new Box3();
      box.setFromObject(inner.current);
      const center = new Vector3();
      box.getSize(center);
      outer.current.position.set(-center.x / 2, -center.y / 2, -center.z / 2);
    }
  }, [children]);
  return /*#__PURE__*/createElement("group", _extends({
    ref: ref
  }, props), /*#__PURE__*/createElement("group", {
    ref: outer
  }, /*#__PURE__*/createElement("group", {
    ref: inner
  }, children)));
});

function Preload({
  all,
  scene,
  camera
}) {
  const {
    gl,
    scene: dScene,
    camera: dCamera
  } = useThree(); // Layout effect because it must run before React commits

  useLayoutEffect(() => {
    const invisible = [];

    if (all) {
      (scene || dScene).traverse(object => {
        if (object.visible === false) {
          invisible.push(object);
          object.visible = true;
        }
      });
    } // Now compile the scene


    gl.compile(scene || dScene, camera || dCamera); // Flips these objects back

    invisible.forEach(object => object.visible = false); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  return null;
}

function useAspect(type, width, height, factor = 1) {
  const {
    viewport: v,
    aspect
  } = useThree();
  const adaptedHeight = height * (aspect > width / height ? v.width / width : v.height / height);
  const adaptedWidth = width * (aspect > width / height ? v.width / width : v.height / height);
  return [adaptedWidth * factor, adaptedHeight * factor, 1];
}

function useCamera(camera, props) {
  const {
    mouse
  } = useThree();
  const [raycast] = useState(() => {
    let raycaster = new Raycaster();
    if (props) applyProps(raycaster, props, {});
    return function (_, intersects) {
      raycaster.setFromCamera(mouse, camera instanceof Camera ? camera : camera.current);
      const rc = this.constructor.prototype.raycast.bind(this);
      if (rc) rc(raycaster, intersects);
    };
  });
  return raycast;
}

function useDetectGPU(props) {
  const [GPUTier, setGPUTier] = useState(null);
  useEffect(() => {
    getGPUTier(props).then(result => setGPUTier(result));
  }, [props]);
  return GPUTier;
}

function useHelper(object3D, proto, ...args) {
  const helper = useRef();
  const {
    scene
  } = useThree();
  useEffect(() => {
    if (proto && object3D.current) {
      helper.current = new proto(object3D.current, ...args);

      if (helper.current) {
        scene.add(helper.current);
      }
    }

    return () => {
      if (helper.current) {
        scene.remove(helper.current);
      }
    };
  }, [scene, proto, object3D, args]);
  useFrame(() => {
    if (helper.current) {
      helper.current.update();
    }
  });
  return helper;
}

/* eslint-disable react-hooks/rules-of-hooks */
function useContextBridge(...contexts) {
  const cRef = useRef([]);
  cRef.current = contexts.map(context => useContext(context));
  return useMemo(() => ({
    children
  }) => contexts.reduceRight((acc, Context, i) => /*#__PURE__*/createElement(Context.Provider, {
    value: cRef.current[i],
    children: acc
  }), children
  /*
   * done this way in reference to:
   * https://github.com/DefinitelyTyped/DefinitelyTyped/issues/44572#issuecomment-625878049
   * https://github.com/microsoft/TypeScript/issues/14729
   */
  ), []);
}

function useAnimations(clips, root) {
  const ref = useRef();
  const actualRef = root ? root : ref;
  const [mixer] = useState(() => new AnimationMixer(undefined));
  const api = useMemo(() => ({
    ref: actualRef,
    clips,
    actions: clips.reduce((prev, clip) => _extends({}, prev, {
      [clip.name]: null
    }), {}),
    names: clips.map(clip => clip.name),
    mixer
  }), [clips, mixer, actualRef]);
  useFrame((state, delta) => mixer.update(delta));
  useEffect(() => {
    const currentRoot = actualRef.current;

    if (currentRoot) {
      clips.forEach(clip => api.actions[clip.name] = mixer.clipAction(clip, currentRoot));
    }

    return () => Object.values(api.actions).forEach(action => {
      if (currentRoot) {
        mixer.uncacheAction(action, currentRoot);
      }
    });
  }, [api, clips, mixer, root, actualRef]);
  return api;
}

// 👇 uncomment when TS version supports function overloads
// export function useFBO(settings?: FBOSettings)
function useFBO(width, height, settings) {
  const {
    size,
    gl
  } = useThree();
  const dpr = useMemo(() => gl.getPixelRatio(), [gl]);

  const _width = typeof width === 'number' ? width : size.width * dpr;

  const _height = typeof height === 'number' ? height : size.height * dpr;

  const _settings = (typeof width === 'number' ? settings : width) || {};

  const target = useMemo(() => {
    const {
      multisample,
      samples
    } = _settings,
          targetSettings = _objectWithoutPropertiesLoose(_settings, ["multisample", "samples"]);

    let target;

    if (multisample && gl.capabilities.isWebGL2) {
      target = new WebGLMultisampleRenderTarget(_width, _height, targetSettings);
      if (samples) target.samples = samples;
    } else {
      target = new WebGLRenderTarget(_width, _height, targetSettings);
    }

    return target; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  useEffect(() => {
    target.setSize(_width, _height);
  }, [target, _width, _height]);
  useEffect(() => {
    return () => target.dispose(); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  return target;
}

function useSimplification(simplePercent) {
  const ref = useRef();
  const original = useRef();
  const modifier = useRef();
  useEffect(() => {
    if (!original.current) {
      original.current = ref.current.geometry.clone();
      modifier.current = new SimplifyModifier();
    }
  }, []);
  useEffect(() => {
    if (original.current && ref.current) {
      let geometry = new BufferGeometry();
      geometry = original.current.clone();
      const count = Math.floor(geometry.attributes.position.count * simplePercent); // number of vertices to remove

      ref.current.geometry = modifier.current.modify(geometry, count);
    }
  }, [simplePercent]);
  return ref;
}

function useTessellation(passes = 3, maxEdgeLength) {
  const ref = useRef();
  const original = useRef();
  const modifier = useRef();
  useEffect(() => {
    if (!original.current) {
      original.current = ref.current.geometry.clone();
      modifier.current = new TessellateModifier(parseInt(maxEdgeLength), passes);
    }
  }, [maxEdgeLength, passes]);
  useEffect(() => {
    modifier.current.maxEdgeLength = maxEdgeLength;
  }, [maxEdgeLength]);
  useEffect(() => {
    if (original.current && ref.current) {
      let geometry = new BufferGeometry();
      geometry = original.current.clone();
      geometry = modifier.current.modify(geometry);
      ref.current.geometry = geometry;
    }
  }, [maxEdgeLength, passes]);
  return ref;
}

function useEdgeSplit(cutOffAngle, tryKeepNormals = true) {
  const ref = useRef();
  const original = useRef();
  const modifier = useRef();
  useEffect(() => {
    if (!original.current && ref.current) {
      original.current = ref.current.geometry.clone();
      modifier.current = new EdgeSplitModifier();
    }
  }, []);
  useEffect(() => {
    if (original.current && ref.current && modifier.current) {
      let geometry = new BufferGeometry();
      geometry = original.current.clone();
      const modifiedGeometry = modifier.current.modify(geometry, cutOffAngle, tryKeepNormals);
      modifiedGeometry.computeVertexNormals();
      ref.current.geometry = modifiedGeometry;
    }
  }, [cutOffAngle, tryKeepNormals]);
  return ref;
}

const CurveModifier = /*#__PURE__*/forwardRef(({
  children,
  curve
}, ref) => {
  const [object3D, setObj] = useState();
  const original = useRef();
  const modifier = useRef();
  useImperativeHandle(ref, () => ({
    moveAlongCurve: val => {
      var _modifier$current;

      (_modifier$current = modifier.current) == null ? void 0 : _modifier$current.moveAlongCurve(val);
    }
  }));
  useEffect(() => {
    if (!modifier.current && original.current && ref) {
      modifier.current = new Flow(original.current);
      setObj(modifier.current.object3D);
    }
  }, [children, ref]);
  useEffect(() => {
    if (original.current && curve) {
      var _modifier$current2;

      (_modifier$current2 = modifier.current) == null ? void 0 : _modifier$current2.updateCurve(0, curve);
    }
  }, [curve]);
  return object3D ? /*#__PURE__*/createElement("primitive", {
    object: object3D
  }) : /*#__PURE__*/cloneElement(Children.only(children), {
    ref: original
  });
});

var distort = "#define GLSLIFY 1\nvec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}float snoise(vec3 v){const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);m=m*m;return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));}"; // eslint-disable-line

class DistortMaterialImpl extends MeshPhysicalMaterial {
  constructor(parameters = {}) {
    super(parameters);

    _defineProperty(this, "_time", void 0);

    _defineProperty(this, "_distort", void 0);

    _defineProperty(this, "_radius", void 0);

    this.setValues(parameters);
    this._time = {
      value: 0
    };
    this._distort = {
      value: 0.4
    };
    this._radius = {
      value: 1
    };
  }

  onBeforeCompile(shader) {
    shader.uniforms.time = this._time;
    shader.uniforms.radius = this._radius;
    shader.uniforms.distort = this._distort;
    shader.vertexShader = "\n      uniform float time;\n      uniform float radius;\n      uniform float distort;\n      " + distort + "\n      " + shader.vertexShader + "\n    ";
    shader.vertexShader = shader.vertexShader.replace('#include <begin_vertex>', "\n        float updateTime = time / 50.0;\n        float noise = snoise(vec3(position / 2.0 + updateTime * 5.0));\n        vec3 transformed = vec3(position * (noise * pow(distort, 2.0) + radius));\n        ");
  }

  get time() {
    return this._time.value;
  }

  set time(v) {
    this._time.value = v;
  }

  get distort() {
    return this._distort.value;
  }

  set distort(v) {
    this._distort.value = v;
  }

  get radius() {
    return this._radius.value;
  }

  set radius(v) {
    this._radius.value = v;
  }

}

const MeshDistortMaterial = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    speed = 1
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["speed"]);

  const [material] = useState(() => new DistortMaterialImpl());
  useFrame(state => material && (material.time = state.clock.getElapsedTime() * speed));
  return /*#__PURE__*/createElement("primitive", _extends({
    dispose: undefined,
    object: material,
    ref: ref,
    attach: "material"
  }, props));
});

class WobbleMaterialImpl extends MeshStandardMaterial {
  constructor(parameters = {}) {
    super(parameters);

    _defineProperty(this, "_time", void 0);

    _defineProperty(this, "_factor", void 0);

    this.setValues(parameters);
    this._time = {
      value: 0
    };
    this._factor = {
      value: 1
    };
  }

  onBeforeCompile(shader) {
    shader.uniforms.time = this._time;
    shader.uniforms.factor = this._factor;
    shader.vertexShader = "\n      uniform float time;\n      uniform float factor;\n      " + shader.vertexShader + "\n    ";
    shader.vertexShader = shader.vertexShader.replace('#include <begin_vertex>', "float theta = sin( time + position.y ) / 2.0 * factor;\n        float c = cos( theta );\n        float s = sin( theta );\n        mat3 m = mat3( c, 0, s, 0, 1, 0, -s, 0, c );\n        vec3 transformed = vec3( position ) * m;\n        vNormal = vNormal * m;");
  }

  get time() {
    return this._time.value;
  }

  set time(v) {
    this._time.value = v;
  }

  get factor() {
    return this._factor.value;
  }

  set factor(v) {
    this._factor.value = v;
  }

}

const MeshWobbleMaterial = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    speed = 1
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["speed"]);

  const [material] = useState(() => new WobbleMaterialImpl());
  useFrame(state => material && (material.time = state.clock.getElapsedTime() * speed));
  return /*#__PURE__*/createElement("primitive", _extends({
    dispose: undefined,
    object: material,
    ref: ref,
    attach: "material"
  }, props));
});

function shaderMaterial(uniforms, vertexShader, fragmentShader, onInit) {
  return class extends ShaderMaterial {
    constructor() {
      const entries = Object.entries(uniforms); // Create unforms and shaders

      super({
        uniforms: entries.reduce((acc, [name, value]) => {
          const uniform = UniformsUtils.clone({
            [name]: {
              value
            }
          });
          return _extends({}, acc, uniform);
        }, {}),
        vertexShader,
        fragmentShader
      }); // Create getter/setters

      entries.forEach(([name]) => Object.defineProperty(this, name, {
        get: () => this.uniforms[name].value,
        set: v => this.uniforms[name].value = v
      }));
      if (onInit) onInit(this);
    }

  };
}

function calcPosFromAngles(inclination, azimuth, vector = new Vector3()) {
  const theta = Math.PI * (inclination - 0.5);
  const phi = 2 * Math.PI * (azimuth - 0.5);
  vector.x = Math.cos(phi);
  vector.y = Math.sin(theta);
  vector.z = Math.sin(phi);
  return vector;
}
const Sky = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    inclination = 0,
    azimuth = 0.25,
    distance = 100,
    mieCoefficient = 0.005,
    mieDirectionalG = 0.8,
    rayleigh = 1,
    turbidity = 2,
    sunPosition = calcPosFromAngles(inclination, azimuth)
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["inclination", "azimuth", "distance", "mieCoefficient", "mieDirectionalG", "rayleigh", "turbidity", "sunPosition"]);

  const scale = useMemo(() => new Vector3().setScalar(distance), [distance]);
  const [sky] = useState(() => new Sky$1());
  return /*#__PURE__*/createElement("primitive", _extends({
    dispose: undefined,
    object: sky,
    ref: ref,
    "material-uniforms-mieCoefficient-value": mieCoefficient,
    "material-uniforms-mieDirectionalG-value": mieDirectionalG,
    "material-uniforms-rayleigh-value": rayleigh,
    "material-uniforms-sunPosition-value": sunPosition,
    "material-uniforms-turbidity-value": turbidity,
    scale: scale
  }, props));
});

const pcss = ({
  frustrum,
  frustum = 3.75,
  size = 0.005,
  near = 9.5,
  samples = 17,
  rings = 11
} = {}) => "#define LIGHT_WORLD_SIZE " + size + "\n#define LIGHT_FRUSTUM_WIDTH " + (frustrum != null ? frustrum : frustum) + "\n#define LIGHT_SIZE_UV (LIGHT_WORLD_SIZE / LIGHT_FRUSTUM_WIDTH)\n#define NEAR_PLANE " + near + "\n\n#define NUM_SAMPLES " + samples + "\n#define NUM_RINGS " + rings + "\n#define BLOCKER_SEARCH_NUM_SAMPLES NUM_SAMPLES\n#define PCF_NUM_SAMPLES NUM_SAMPLES\n\nvec2 poissonDisk[NUM_SAMPLES];\n\nvoid initPoissonSamples(const in vec2 randomSeed) {\n\tfloat ANGLE_STEP = PI2 * float(NUM_RINGS) / float(NUM_SAMPLES);\n\tfloat INV_NUM_SAMPLES = 1.0 / float(NUM_SAMPLES);\n\tfloat angle = rand(randomSeed) * PI2;\n\tfloat radius = INV_NUM_SAMPLES;\n\tfloat radiusStep = radius;\n\tfor (int i = 0; i < NUM_SAMPLES; i++) {\n\t\tpoissonDisk[i] = vec2(cos(angle), sin(angle)) * pow(radius, 0.75);\n\t\tradius += radiusStep;\n\t\tangle += ANGLE_STEP;\n\t}\n}\n\nfloat penumbraSize(const in float zReceiver, const in float zBlocker) { // Parallel plane estimation\n\treturn (zReceiver - zBlocker) / zBlocker;\n}\n\nfloat findBlocker(sampler2D shadowMap, const in vec2 uv, const in float zReceiver) {\n\tfloat searchRadius = LIGHT_SIZE_UV * (zReceiver - NEAR_PLANE) / zReceiver;\n\tfloat blockerDepthSum = 0.0;\n\tint numBlockers = 0;\n\tfor (int i = 0; i < BLOCKER_SEARCH_NUM_SAMPLES; i++) {\n\t\tfloat shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));\n\t\tif (shadowMapDepth < zReceiver) {\n\t\t\tblockerDepthSum += shadowMapDepth;\n\t\t\tnumBlockers++;\n\t\t}\n\t}\n\tif (numBlockers == 0) return -1.0;\n\treturn blockerDepthSum / float(numBlockers);\n}\n\nfloat PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius) {\n\tfloat sum = 0.0;\n\tfor (int i = 0; i < PCF_NUM_SAMPLES; i++) {\n\t\tfloat depth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[ i ] * filterRadius));\n\t\tif (zReceiver <= depth) sum += 1.0;\n\t}\n\tfor (int i = 0; i < PCF_NUM_SAMPLES; i++) {\n\t\tfloat depth = unpackRGBAToDepth(texture2D(shadowMap, uv + -poissonDisk[ i ].yx * filterRadius));\n\t\tif (zReceiver <= depth) sum += 1.0;\n\t}\n\treturn sum / (2.0 * float(PCF_NUM_SAMPLES));\n}\n\nfloat PCSS(sampler2D shadowMap, vec4 coords) {\n\tvec2 uv = coords.xy;\n\tfloat zReceiver = coords.z; // Assumed to be eye-space z in this code\n\tinitPoissonSamples(uv);\n\tfloat avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver);\n\tif (avgBlockerDepth == -1.0) return 1.0;\n\tfloat penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);\n\tfloat filterRadius = penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;\n\treturn PCF_Filter(shadowMap, uv, zReceiver, filterRadius);\n}";

let deployed = false;
const softShadows = props => {
  // Avoid adding the effect twice, which may happen in HMR scenarios
  if (!deployed) {
    if (props == null ? void 0 : props.frustrum) {
      console.warn('You have used an incorrect spelling of frustrum, this will be deprecated in the future');
    }

    deployed = true;
    let shader = ShaderChunk.shadowmap_pars_fragment;
    shader = shader.replace('#ifdef USE_SHADOWMAP', '#ifdef USE_SHADOWMAP\n' + pcss(_extends({}, props)));
    shader = shader.replace('#if defined( SHADOWMAP_TYPE_PCF )', '\nreturn PCSS(shadowMap, shadowCoord);\n#if defined( SHADOWMAP_TYPE_PCF )');
    ShaderChunk.shadowmap_pars_fragment = shader;
  }
};

class StarfieldMaterial extends ShaderMaterial {
  constructor() {
    super({
      uniforms: {
        time: {
          value: 0.0
        },
        fade: {
          value: 1.0
        }
      },
      vertexShader: "uniform float time;\n      attribute float size;\n      varying vec3 vColor;\n      void main() {\n        vColor = color;\n        vec4 mvPosition = modelViewMatrix * vec4(position, 0.5);\n        gl_PointSize = size * (30.0 / -mvPosition.z) * (3.0 + sin(mvPosition.x + 2.0 * time + 100.0));\n        gl_Position = projectionMatrix * mvPosition;\n      }",
      fragmentShader: "uniform sampler2D pointTexture;\n      uniform float fade;\n      varying vec3 vColor;\n      void main() {\n        float opacity = 1.0;\n        if (fade == 1.0) {\n          float d = distance(gl_PointCoord, vec2(0.5, 0.5));\n          opacity = 1.0 / (1.0 + exp(16.0 * (d - 0.25)));\n        }\n        gl_FragColor = vec4(vColor, opacity);\n      }"
    });
  }

}

const genStar = r => {
  return new Vector3().setFromSpherical(new Spherical(r, Math.acos(1 - Math.random() * 2), Math.random() * 2 * Math.PI));
};

const Stars = /*#__PURE__*/forwardRef(({
  radius = 100,
  depth = 50,
  count = 5000,
  saturation = 0,
  factor = 4,
  fade = false
}, ref) => {
  const material = useRef();
  const [position, color, size] = useMemo(() => {
    const positions = [];
    const colors = [];
    const sizes = Array.from({
      length: count
    }, () => (0.5 + 0.5 * Math.random()) * factor);
    const color = new Color();
    let r = radius + depth;
    const increment = depth / count;

    for (let i = 0; i < count; i++) {
      r -= increment * Math.random();
      positions.push(...genStar(r).toArray());
      color.setHSL(i / count, saturation, 0.9);
      colors.push(color.r, color.g, color.b);
    }

    return [new Float32Array(positions), new Float32Array(colors), new Float32Array(sizes)];
  }, [count, depth, factor, radius, saturation]);
  useFrame(state => material.current && (material.current.uniforms.time.value = state.clock.getElapsedTime()));
  const [starfieldMaterial] = useState(() => new StarfieldMaterial());
  return /*#__PURE__*/createElement("points", {
    ref: ref
  }, /*#__PURE__*/createElement("bufferGeometry", {
    attach: "geometry"
  }, /*#__PURE__*/createElement("bufferAttribute", {
    attachObject: ['attributes', 'position'],
    args: [position, 3]
  }), /*#__PURE__*/createElement("bufferAttribute", {
    attachObject: ['attributes', 'color'],
    args: [color, 3]
  }), /*#__PURE__*/createElement("bufferAttribute", {
    attachObject: ['attributes', 'size'],
    args: [size, 1]
  })), /*#__PURE__*/createElement("primitive", {
    dispose: undefined,
    ref: material,
    object: starfieldMaterial,
    attach: "material",
    blending: AdditiveBlending,
    "uniforms-fade-value": fade,
    transparent: true,
    vertexColors: true
  }));
});

const ContactShadows = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    opacity = 1,
    width = 1,
    height = 1,
    blur = 1,
    far = 10,
    resolution = 256
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["opacity", "width", "height", "blur", "far", "resolution"]);

  const {
    scene,
    gl
  } = useThree();
  const shadowCamera = useRef();
  const [renderTarget, planeGeometry, depthMaterial, blurPlane, horizontalBlurMaterial, verticalBlurMaterial, renderTargetBlur] = useMemo(() => {
    const renderTarget = new WebGLRenderTarget(resolution, resolution);
    const renderTargetBlur = new WebGLRenderTarget(resolution, resolution);
    renderTargetBlur.texture.generateMipmaps = renderTarget.texture.generateMipmaps = false;
    const planeGeometry = new PlaneBufferGeometry(width, height).rotateX(Math.PI / 2);
    const blurPlane = new Mesh(planeGeometry);
    const depthMaterial = new MeshDepthMaterial();
    depthMaterial.depthTest = depthMaterial.depthWrite = false;

    depthMaterial.onBeforeCompile = shader => shader.fragmentShader = shader.fragmentShader.replace('1.0 - fragCoordZ ), opacity );', '0.0 ), ( 1.0 - fragCoordZ ) * 1.0 );');

    const horizontalBlurMaterial = new ShaderMaterial(HorizontalBlurShader);
    const verticalBlurMaterial = new ShaderMaterial(VerticalBlurShader);
    verticalBlurMaterial.depthTest = horizontalBlurMaterial.depthTest = false;
    return [renderTarget, planeGeometry, depthMaterial, blurPlane, horizontalBlurMaterial, verticalBlurMaterial, renderTargetBlur];
  }, [resolution, width, height]);
  useFrame(() => {
    if (shadowCamera.current) {
      const initialBackground = scene.background;
      scene.background = null;
      scene.overrideMaterial = depthMaterial;
      gl.setRenderTarget(renderTarget);
      gl.render(scene, shadowCamera.current);
      scene.overrideMaterial = null;
      blurPlane.material = horizontalBlurMaterial;
      blurPlane.material.uniforms.tDiffuse.value = renderTarget.texture;
      horizontalBlurMaterial.uniforms.h.value = blur / 256;
      gl.setRenderTarget(renderTargetBlur);
      gl.render(blurPlane, shadowCamera.current);
      blurPlane.material = verticalBlurMaterial;
      blurPlane.material.uniforms.tDiffuse.value = renderTargetBlur.texture;
      verticalBlurMaterial.uniforms.v.value = blur / 256;
      gl.setRenderTarget(renderTarget);
      gl.render(blurPlane, shadowCamera.current);
      gl.setRenderTarget(null);
      scene.background = initialBackground;
    }
  });
  return /*#__PURE__*/createElement("group", _extends({}, props, {
    ref: ref
  }), /*#__PURE__*/createElement("mesh", {
    geometry: planeGeometry,
    scale: [1, -1, 1],
    rotation: [-Math.PI / 2, 0, 0]
  }, /*#__PURE__*/createElement("meshBasicMaterial", {
    map: renderTarget.texture,
    transparent: true,
    opacity: opacity
  })), /*#__PURE__*/createElement("orthographicCamera", {
    ref: shadowCamera,
    args: [-width / 2, width / 2, height / 2, -height / 2, 0, far]
  }));
});

const eps = 0.00001;

function createShape(width, height, radius0) {
  const shape = new Shape();
  const radius = radius0 - eps;
  shape.absarc(eps, eps, eps, -Math.PI / 2, -Math.PI, true);
  shape.absarc(eps, height - radius * 2, eps, Math.PI, Math.PI / 2, true);
  shape.absarc(width - radius * 2, height - radius * 2, eps, Math.PI / 2, 0, true);
  shape.absarc(width - radius * 2, eps, eps, 0, -Math.PI / 2, true);
  return shape;
}

const RoundedBox = /*#__PURE__*/forwardRef(function RoundedBox(_ref, ref) {
  let {
    args: [width = 1, height = 1, depth = 1] = [],
    radius = 0.05,
    smoothness = 4,
    children
  } = _ref,
      rest = _objectWithoutPropertiesLoose(_ref, ["args", "radius", "smoothness", "children"]);

  const shape = useMemo(() => createShape(width, height, radius), [width, height, radius]);
  const params = useMemo(() => ({
    depth: depth - radius * 2,
    bevelEnabled: true,
    bevelSegments: smoothness * 2,
    steps: 1,
    bevelSize: radius - eps,
    bevelThickness: radius,
    curveSegments: smoothness
  }), [depth, radius, smoothness]);
  const geomRef = useUpdate(geometry => void geometry.center(), [shape, params]);
  return /*#__PURE__*/createElement("mesh", _extends({
    ref: ref
  }, rest), /*#__PURE__*/createElement("extrudeBufferGeometry", {
    attach: "geometry",
    ref: geomRef,
    args: [shape, params]
  }), children);
});

function createScreenQuadGeometry() {
  const geometry = new BufferGeometry();
  const vertices = new Float32Array([-1, -1, 3, -1, -1, 3]);
  geometry.setAttribute('position', new BufferAttribute(vertices, 2));
  return geometry;
}

const ScreenQuad = /*#__PURE__*/forwardRef(function ScreenQuad(_ref, ref) {
  let {
    children
  } = _ref,
      restProps = _objectWithoutPropertiesLoose(_ref, ["children"]);

  const geometry = useMemo(createScreenQuadGeometry, []);
  return /*#__PURE__*/createElement("mesh", _extends({
    ref: ref,
    geometry: geometry,
    frustumCulled: false
  }, restProps), children);
});

function getFormatString(format) {
  switch (format) {
    case 64:
      return '-64px';

    case 128:
      return '-128px';

    case 256:
      return '-256px';

    case 512:
      return '-512px';

    default:
      return '';
  }
}

const MATCAP_ROOT = 'https://rawcdn.githack.com/emmelleppi/matcaps/9b36ccaaf0a24881a39062d05566c9e92be4aa0d';
const DEFAULT_MATCAP = matcapList[0];
function useMatcapTexture(id = 0, format = 1024) {
  const numTot = useMemo(() => Object.keys(matcapList).length, []);
  const fileHash = useMemo(() => {
    if (typeof id === 'string') {
      return id;
    } else if (typeof id === 'number') {
      return matcapList[id];
    }

    return null;
  }, [id]);
  const fileName = "" + (fileHash || DEFAULT_MATCAP) + getFormatString(format) + ".png";
  const url = MATCAP_ROOT + "/" + format + "/" + fileName;
  const matcapTexture = useTexture(url);
  return [matcapTexture, url, numTot];
}

const NORMAL_ROOT = 'https://rawcdn.githack.com/emmelleppi/normal-maps/f24c810fc1d86b5b1e5dfea914b668f70b5f2923';
const DEFAULT_NORMAL = normalsList[0];
function useNormalTexture(id = 0, settings = {}) {
  const {
    repeat = [1, 1],
    anisotropy = 1,
    offset = [0, 0]
  } = settings;
  const numTot = useMemo(() => Object.keys(normalsList).length, []);
  const imageName = normalsList[id] || DEFAULT_NORMAL;
  const url = NORMAL_ROOT + "/normals/" + imageName;
  const normalTexture = useTexture(url);
  useEffect(() => {
    if (!normalTexture) return;
    normalTexture.wrapS = normalTexture.wrapT = RepeatWrapping;
    normalTexture.repeat = new Vector2(repeat[0], repeat[1]);
    normalTexture.offset = new Vector2(offset[0], offset[1]);
    normalTexture.anisotropy = anisotropy;
  }, [normalTexture, anisotropy, repeat, offset]);
  return [normalTexture, url, numTot];
}

export { Cylinder as $, useSimplification as A, Billboard as B, Cloud as C, Detailed as D, Environment as E, FlyControls as F, useTessellation as G, useEdgeSplit as H, CurveModifier as I, MeshDistortMaterial as J, MeshWobbleMaterial as K, Line as L, MapControls as M, shaderMaterial as N, OrthographicCamera as O, PositionalAudio as P, calcPosFromAngles as Q, Reflector as R, Shadow as S, Text as T, Sky as U, softShadows as V, Stars as W, ContactShadows as X, Box as Y, Circle as Z, Cone as _, Effects as a, Sphere as a0, Plane as a1, Tube as a2, Torus as a3, TorusKnot as a4, Tetrahedron as a5, Ring as a6, Polyhedron as a7, Icosahedron as a8, Octahedron as a9, Dodecahedron as aa, Extrude as ab, Lathe as ac, Parametric as ad, RoundedBox as ae, ScreenQuad as af, useMatcapTexture as ag, useNormalTexture as ah, PerspectiveCamera as b, CameraShake as c, CubeCamera as d, DeviceOrientationControls as e, OrbitControls as f, TrackballControls as g, TransformControls as h, isWebGL2Available as i, PointerLockControls as j, useFBX as k, useGLTF as l, useProgress as m, useTexture as n, meshBounds as o, Stats as p, Center as q, Preload as r, useAspect as s, useCamera as t, useCubeTexture as u, useDetectGPU as v, useHelper as w, useContextBridge as x, useAnimations as y, useFBO as z };
