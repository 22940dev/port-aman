import _extends from '@babel/runtime/helpers/esm/extends';
import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';
import { forwardRef, useState, useRef, useEffect, useMemo, useLayoutEffect, createElement } from 'react';
import { unmountComponentAtNode, render } from 'react-dom';
import { Vector3, OrthographicCamera, PerspectiveCamera } from 'three';
import { useThree, useFrame } from 'react-three-fiber';

const v1 = new Vector3();
const v2 = new Vector3();
const v3 = new Vector3();

function defaultCalculatePosition(el, camera, size) {
  const objectPos = v1.setFromMatrixPosition(el.matrixWorld);
  objectPos.project(camera);
  const widthHalf = size.width / 2;
  const heightHalf = size.height / 2;
  return [objectPos.x * widthHalf + widthHalf, -(objectPos.y * heightHalf) + heightHalf];
}

function isObjectBehindCamera(el, camera) {
  const objectPos = v1.setFromMatrixPosition(el.matrixWorld);
  const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
  const deltaCamObj = objectPos.sub(cameraPos);
  const camDir = camera.getWorldDirection(v3);
  return deltaCamObj.angleTo(camDir) > Math.PI / 2;
}

function objectScale(el, camera) {
  const objectPos = v1.setFromMatrixPosition(el.matrixWorld);
  const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
  const vFOV = camera.fov * Math.PI / 180;
  const dist = objectPos.distanceTo(cameraPos);
  const scaleFOV = 2 * Math.tan(vFOV / 2) * dist;

  if (camera instanceof OrthographicCamera) {
    return 1 / (scaleFOV / camera.zoom);
  } else if (camera instanceof PerspectiveCamera) {
    return 1 / scaleFOV;
  } else {
    return 1;
  }
}

function objectZIndex(el, camera, zIndexRange) {
  if (camera instanceof PerspectiveCamera || camera instanceof OrthographicCamera) {
    const objectPos = v1.setFromMatrixPosition(el.matrixWorld);
    const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
    const dist = objectPos.distanceTo(cameraPos);
    const A = (zIndexRange[1] - zIndexRange[0]) / (camera.far - camera.near);
    const B = zIndexRange[1] - A * camera.far;
    return Math.round(A * dist + B);
  }

  return undefined;
}

const Html = /*#__PURE__*/forwardRef((_ref, ref) => {
  var _portal$current, _gl$domElement;

  let {
    children,
    eps = 0.001,
    style,
    className,
    prepend,
    center,
    fullscreen,
    portal,
    scaleFactor,
    zIndexRange = [16777271, 0],
    calculatePosition = defaultCalculatePosition
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["children", "eps", "style", "className", "prepend", "center", "fullscreen", "portal", "scaleFactor", "zIndexRange", "calculatePosition"]);

  const {
    gl,
    scene,
    camera,
    size
  } = useThree();
  const [el] = useState(() => document.createElement('div'));
  const group = useRef(null);
  const old = useRef([0, 0]);
  const target = (_portal$current = portal == null ? void 0 : portal.current) != null ? _portal$current : (_gl$domElement = gl.domElement) == null ? void 0 : _gl$domElement.parentNode;
  useEffect(() => {
    if (group.current) {
      scene.updateMatrixWorld();
      const vec = calculatePosition(group.current, camera, size);
      el.style.cssText = "position:absolute;top:0;left:0;transform:translate3d(" + vec[0] + "px," + vec[1] + "px,0);transform-origin:0 0;";

      if (target) {
        if (prepend) target.prepend(el);else target.appendChild(el);
      }

      return () => {
        if (target) target.removeChild(el);
        unmountComponentAtNode(el);
      };
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, [target]);
  const styles = useMemo(() => _extends({
    position: 'absolute',
    transform: center ? 'translate3d(-50%,-50%,0)' : 'none'
  }, fullscreen && {
    top: -size.height / 2,
    left: -size.width / 2,
    width: size.width,
    height: size.height
  }, style), [style, center, fullscreen, size]);
  useLayoutEffect(() => void render( /*#__PURE__*/createElement("div", {
    ref: ref,
    style: styles,
    className: className,
    children: children
  }), el));
  useFrame(() => {
    if (group.current) {
      camera.updateMatrixWorld();
      const vec = calculatePosition(group.current, camera, size);

      if (Math.abs(old.current[0] - vec[0]) > eps || Math.abs(old.current[1] - vec[1]) > eps) {
        el.style.display = !isObjectBehindCamera(group.current, camera) ? 'block' : 'none';
        const scale = scaleFactor === undefined ? 1 : objectScale(group.current, camera) * scaleFactor;
        el.style.transform = "translate3d(" + vec[0] + "px," + vec[1] + "px,0) scale(" + scale + ")";
        el.style.zIndex = "" + objectZIndex(group.current, camera, zIndexRange);
      }

      old.current = vec;
    }
  });
  return /*#__PURE__*/createElement("group", _extends({}, props, {
    ref: group
  }));
});

export { Html };
