{"version":3,"sources":["webpack:///./node_modules/refractor/lang/http.js"],"names":["http","Prism","languages","pattern","inside","property","lookbehind","alias","options","langs","httpLanguages","javascript","json","xml","html","css","suffixTypes","getSuffixPattern","contentType","suffix","replace","RegExp","rest","insertBefore","module","exports","displayName","aliases"],"mappings":"4FAMA,SAASA,EAAKC,IAGZ,SAAWA,GACTA,EAAMC,UAAUF,KAAO,CACrB,eAAgB,CACdG,QAAS,8FACTC,OAAQ,CAENC,SAAU,yDAEV,YAAa,SAGjB,kBAAmB,CACjBF,QAAS,uBACTC,OAAQ,CAENC,SAAU,CACRF,QAAS,yBACTG,YAAY,KAKlB,cAAe,CACbH,QAAS,iBACTI,MAAO,YAIX,IA6BIC,EA7BAC,EAAQR,EAAMC,UACdQ,EAAgB,CAClB,yBAA0BD,EAAME,WAChC,mBAAoBF,EAAMG,MAAQH,EAAME,WACxC,kBAAmBF,EAAMI,IACzB,WAAYJ,EAAMI,IAClB,YAAaJ,EAAMK,KACnB,WAAYL,EAAMM,KAGhBC,EAAc,CAChB,oBAAoB,EACpB,mBAAmB,GASrB,SAASC,EAAiBC,GACxB,IAAIC,EAASD,EAAYE,QAAQ,YAAa,IAE9C,MAAO,MAAQF,EAAc,KADT,wBAA0BC,EAAS,gBACJ,IAOrD,IAAK,IAAID,KAAeR,EACtB,GAAIA,EAAcQ,GAAc,CAC9BV,EAAUA,GAAW,GACrB,IAAIL,EAAUa,EAAYE,GAAeD,EAAiBC,GAAeA,EACzEV,EAAQU,GAAe,CACrBf,QAASkB,OAAO,qBAAuBlB,EAAU,yCAA0C,KAC3FG,YAAY,EACZF,OAAQ,CACNkB,KAAMZ,EAAcQ,KAMxBV,GACFP,EAAMC,UAAUqB,aAAa,OAAQ,cAAef,GA1ExD,CA4EGP,GAnFLuB,EAAOC,QAAUzB,EACjBA,EAAK0B,YAAc,OACnB1B,EAAK2B,QAAU","file":"react-syntax-highlighter_languages_refractor_http-44dee26efb7e53ab6b2b.js","sourcesContent":["'use strict';\n\nmodule.exports = http;\nhttp.displayName = 'http';\nhttp.aliases = [];\n\nfunction http(Prism) {\n  ;\n\n  (function (Prism) {\n    Prism.languages.http = {\n      'request-line': {\n        pattern: /^(?:POST|GET|PUT|DELETE|OPTIONS|PATCH|TRACE|CONNECT)\\s(?:https?:\\/\\/|\\/)\\S+\\sHTTP\\/[0-9.]+/m,\n        inside: {\n          // HTTP Verb\n          property: /^(?:POST|GET|PUT|DELETE|OPTIONS|PATCH|TRACE|CONNECT)\\b/,\n          // Path or query argument\n          'attr-name': /:\\w+/\n        }\n      },\n      'response-status': {\n        pattern: /^HTTP\\/1.[01] \\d+.*/m,\n        inside: {\n          // Status, e.g. 200 OK\n          property: {\n            pattern: /(^HTTP\\/1.[01] )\\d+.*/i,\n            lookbehind: true\n          }\n        }\n      },\n      // HTTP header name\n      'header-name': {\n        pattern: /^[\\w-]+:(?=.)/m,\n        alias: 'keyword'\n      }\n    }; // Create a mapping of Content-Type headers to language definitions\n\n    var langs = Prism.languages;\n    var httpLanguages = {\n      'application/javascript': langs.javascript,\n      'application/json': langs.json || langs.javascript,\n      'application/xml': langs.xml,\n      'text/xml': langs.xml,\n      'text/html': langs.html,\n      'text/css': langs.css\n    }; // Declare which types can also be suffixes\n\n    var suffixTypes = {\n      'application/json': true,\n      'application/xml': true\n    };\n    /**\n     * Returns a pattern for the given content type which matches it and any type which has it as a suffix.\n     *\n     * @param {string} contentType\n     * @returns {string}\n     */\n\n    function getSuffixPattern(contentType) {\n      var suffix = contentType.replace(/^[a-z]+\\//, '');\n      var suffixPattern = '\\\\w+/(?:[\\\\w.-]+\\\\+)+' + suffix + '(?![+\\\\w.-])';\n      return '(?:' + contentType + '|' + suffixPattern + ')';\n    } // Insert each content type parser that has its associated language\n    // currently loaded.\n\n\n    var options;\n\n    for (var contentType in httpLanguages) {\n      if (httpLanguages[contentType]) {\n        options = options || {};\n        var pattern = suffixTypes[contentType] ? getSuffixPattern(contentType) : contentType;\n        options[contentType] = {\n          pattern: RegExp('(content-type:\\\\s*' + pattern + '[\\\\s\\\\S]*?)(?:\\\\r?\\\\n|\\\\r){2}[\\\\s\\\\S]*', 'i'),\n          lookbehind: true,\n          inside: {\n            rest: httpLanguages[contentType]\n          }\n        };\n      }\n    }\n\n    if (options) {\n      Prism.languages.insertBefore('http', 'header-name', options);\n    }\n  })(Prism);\n}"],"sourceRoot":""}